/*
 * Copyright 2025 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Auto-generated code. Do not edit.

package com.google.genai.types;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.google.auto.value.AutoValue;
import com.google.errorprone.annotations.CanIgnoreReturnValue;
import com.google.genai.JsonSerializable;
import java.util.Optional;

/**
 * Success and error statistics of processing multiple entities (for example, DataItems or
 * structured data rows) in batch. This data type is not supported in Gemini API.
 */
@AutoValue
@JsonDeserialize(builder = CompletionStats.Builder.class)
public abstract class CompletionStats extends JsonSerializable {
  /** Output only. The number of entities for which any error was encountered. */
  @JsonProperty("failedCount")
  public abstract Optional<Long> failedCount();

  /**
   * Output only. In cases when enough errors are encountered a job, pipeline, or operation may be
   * failed as a whole. Below is the number of entities for which the processing had not been
   * finished (either in successful or failed state). Set to -1 if the number is unknown (for
   * example, the operation failed before the total entity number could be collected).
   */
  @JsonProperty("incompleteCount")
  public abstract Optional<Long> incompleteCount();

  /** Output only. The number of entities that had been processed successfully. */
  @JsonProperty("successfulCount")
  public abstract Optional<Long> successfulCount();

  /**
   * Output only. The number of the successful forecast points that are generated by the forecasting
   * model. This is ONLY used by the forecasting batch prediction.
   */
  @JsonProperty("successfulForecastPointCount")
  public abstract Optional<Long> successfulForecastPointCount();

  /** Instantiates a builder for CompletionStats. */
  @ExcludeFromGeneratedCoverageReport
  public static Builder builder() {
    return new AutoValue_CompletionStats.Builder();
  }

  /** Creates a builder with the same values as this instance. */
  public abstract Builder toBuilder();

  /** Builder for CompletionStats. */
  @AutoValue.Builder
  public abstract static class Builder {
    /** For internal usage. Please use `CompletionStats.builder()` for instantiation. */
    @JsonCreator
    private static Builder create() {
      return new AutoValue_CompletionStats.Builder();
    }

    /**
     * Setter for failedCount.
     *
     * <p>failedCount: Output only. The number of entities for which any error was encountered.
     */
    @JsonProperty("failedCount")
    public abstract Builder failedCount(Long failedCount);

    @ExcludeFromGeneratedCoverageReport
    abstract Builder failedCount(Optional<Long> failedCount);

    /** Clears the value of failedCount field. */
    @ExcludeFromGeneratedCoverageReport
    @CanIgnoreReturnValue
    public Builder clearFailedCount() {
      return failedCount(Optional.empty());
    }

    /**
     * Setter for incompleteCount.
     *
     * <p>incompleteCount: Output only. In cases when enough errors are encountered a job, pipeline,
     * or operation may be failed as a whole. Below is the number of entities for which the
     * processing had not been finished (either in successful or failed state). Set to -1 if the
     * number is unknown (for example, the operation failed before the total entity number could be
     * collected).
     */
    @JsonProperty("incompleteCount")
    public abstract Builder incompleteCount(Long incompleteCount);

    @ExcludeFromGeneratedCoverageReport
    abstract Builder incompleteCount(Optional<Long> incompleteCount);

    /** Clears the value of incompleteCount field. */
    @ExcludeFromGeneratedCoverageReport
    @CanIgnoreReturnValue
    public Builder clearIncompleteCount() {
      return incompleteCount(Optional.empty());
    }

    /**
     * Setter for successfulCount.
     *
     * <p>successfulCount: Output only. The number of entities that had been processed successfully.
     */
    @JsonProperty("successfulCount")
    public abstract Builder successfulCount(Long successfulCount);

    @ExcludeFromGeneratedCoverageReport
    abstract Builder successfulCount(Optional<Long> successfulCount);

    /** Clears the value of successfulCount field. */
    @ExcludeFromGeneratedCoverageReport
    @CanIgnoreReturnValue
    public Builder clearSuccessfulCount() {
      return successfulCount(Optional.empty());
    }

    /**
     * Setter for successfulForecastPointCount.
     *
     * <p>successfulForecastPointCount: Output only. The number of the successful forecast points
     * that are generated by the forecasting model. This is ONLY used by the forecasting batch
     * prediction.
     */
    @JsonProperty("successfulForecastPointCount")
    public abstract Builder successfulForecastPointCount(Long successfulForecastPointCount);

    @ExcludeFromGeneratedCoverageReport
    abstract Builder successfulForecastPointCount(Optional<Long> successfulForecastPointCount);

    /** Clears the value of successfulForecastPointCount field. */
    @ExcludeFromGeneratedCoverageReport
    @CanIgnoreReturnValue
    public Builder clearSuccessfulForecastPointCount() {
      return successfulForecastPointCount(Optional.empty());
    }

    public abstract CompletionStats build();
  }

  /** Deserializes a JSON string to a CompletionStats object. */
  @ExcludeFromGeneratedCoverageReport
  public static CompletionStats fromJson(String jsonString) {
    return JsonSerializable.fromJsonString(jsonString, CompletionStats.class);
  }
}
